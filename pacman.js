// Generated by LiveScript 1.2.0
(function(){
  var Bacon, multimethod, Heap, commutativeMultimethod, Geometry, stop, velocity, setVelocity, rectangle, interval, len, intersection, at, shiftBy, collisionInterval, drawFrom, own, print, maybe, compare, compareBy, breakAt, collision, nextCollision, outcome, events, step, board, takeStep, result, create, roller, ref$, grid, i, prime, slice$ = [].slice;
  import$(global, require('prelude-ls'));
  Bacon = require('baconjs');
  multimethod = require('multimethod');
  Heap = require('Heap');
  commutativeMultimethod = require('./commutative-multimethod');
  Geometry = require('./Geometry');
  stop = Geometry.stop, velocity = Geometry.velocity, setVelocity = Geometry.setVelocity, rectangle = Geometry.rectangle, interval = Geometry.interval, len = Geometry.len, intersection = Geometry.intersection, at = Geometry.at, shiftBy = Geometry.shiftBy, collisionInterval = Geometry.collisionInterval;
  drawFrom = function(dist){
    var go;
    go = function(x, arg$){
      var ref$, l, p, r;
      ref$ = arg$[0], l = ref$[0], p = ref$[1], r = slice$.call(arg$, 1);
      if (x < p || empty(r)) {
        return l;
      } else {
        return go(x - p, r);
      }
    };
    return go(Math.random() * sum(values(dist)), objToPairs(dist));
  };
  own = function(obj){
    var k, v;
    switch (false) {
    case typeof obj !== 'object':
      return import$([], (function(){
        var ref$, results$ = {};
        for (k in ref$ = obj) {
          v = ref$[k];
          results$[k] = own(v);
        }
        return results$;
      }()));
    default:
      return obj;
    }
  };
  print = function(){
    return console.log(own.apply(this, arguments));
  };
  maybe = curry$(function(v, f){
    if (v != null) {
      return f(v);
    }
  });
  compare = curry$(function(a, b){
    switch (false) {
    case !(a < b):
      return -1;
    case !(a > b):
      return 1;
    case a !== b:
      return 0;
    }
  });
  compareBy = curry$(function(f, a, b){
    return compare(f(a), f(b));
  });
  breakAt = function(obj, wall){
    var h, v, i, firstHalf, secondHalf, ref$;
    h = intersection(wall[0], obj[0]);
    v = intersection(wall[1], obj[1]);
    i = len(h) < len(v) ? 1 : 0;
    firstHalf = clone$(wall);
    secondHalf = clone$(wall);
    firstHalf[i] = (ref$ = interval(wall[i].a, obj[i].a), ref$.v = wall[i].v, ref$);
    secondHalf[i] = interval(obj[i].b, (ref$ = wall[i].b, ref$.v = wall[i].v, ref$));
    return filter(function(it){
      return it[i] != null;
    }, [firstHalf, secondHalf]);
  };
  collision = commutativeMultimethod(function(it){
    return it.type;
  })['default'](id).when('wall', 'pacman', function(wall, pacman){
    return [wall, stop(pacman)];
  }).when('wall', 'ghost', function(wall, ghost){
    return [wall, stop(ghost)];
  }).when('wall', 'roller', function(wall, roller){
    return breakAt(roller, wall).concat(roller);
  }).when('pacman', 'ghost', function(pacman, ghost){
    var ref$;
    return [(ref$ = clone$(pacman), ref$.dead = true, ref$), ghost];
  });
  nextCollision = function(board){
    var time, i$, len$, i, j$, j, I, ref$, ii, jj;
    time = Infinity;
    for (i$ = 0, len$ = board.length; i$ < len$; ++i$) {
      i = i$;
      for (j$ = 0; j$ < i; ++j$) {
        j = j$;
        I = collisionInterval(board[i], board[j]);
        if (I != null && (board.time <= (ref$ = I.a) && ref$ < time)) {
          ref$ = [i, j], ii = ref$[0], jj = ref$[1];
          time = I.a;
        }
      }
    }
    if (ii != null) {
      return ref$ = slice$.call(board, 0, jj).concat(slice$.call(board, jj + 1, ii), slice$.call(board, ii + 1), collision(board[ii], board[jj])), ref$.time = time, ref$;
    }
  };
  outcome = curry$(function(event, board){
    board = (function(){
      var ref$;
      switch (event.type) {
      case 'add':
        return board.concat((ref$ = clone$(event.obj), ref$.time = event.time, ref$));
      default:
        return clone$(board);
      }
    }());
    return board.time = event.time, board;
  });
  events = new Heap(compareBy(function(it){
    return it.time;
  }));
  step = function(board){
    var roller, time, next, col, i$, len$, i, obj, action;
    if (true && (roller = find(function(it){
      return it.type === 'roller';
    }, board))) {
      console.log(roller[0].a, roller[1].a);
      console.log(velocity(roller));
      console.log(roller.time);
    }
    time = Infinity;
    if (!events.empty()) {
      time = events.top().time;
      next = function(){
        return outcome(events.pop(), board);
      };
    }
    col = nextCollision(board);
    if (col != null && col.time <= time) {
      time = col.time;
      next = function(){
        return col;
      };
    }
    for (i$ = 0, len$ = board.length; i$ < len$; ++i$) {
      i = i$;
      obj = board[i$];
      if (obj.action != null) {
        action = obj.action(board);
      }
      if (action != null && action.time <= time) {
        time = action.time;
        next = fn$;
      }
    }
    return next;
    function fn$(){
      var ref$;
      return ref$ = clone$(map(flip$(at)(time), board)), ref$[i] = action(), ref$.time = action.time, ref$;
    }
  };
  board = [];
  takeStep = function(){
    var s;
    s = step(board);
    if (s != null) {
      board = s[1]();
      print(board);
    } else {
      console.log("That's it");
      if (board.done) {
        board = [];
      }
      board.done = true;
    }
    return board;
  };
  result = function(board){
    var s;
    s = step(board);
    if (s != null) {
      return result(s());
    } else {
      return board;
    }
  };
  create = function(type, xSpan, ySpan, v){
    v == null && (v = [0, 0]);
    return (function(it){
      return it.type = type, it;
    })(
    setVelocity(rectangle(xSpan, ySpan), v));
  };
  roller = (ref$ = create('roller', [0, 1], [0, 1], [0, 1]), ref$.action = function(board){
    var time, roller;
    if (board.time < 10) {
      time = 2 + 2 * floor(board.time / 2);
      roller = this;
      return (function(it){
        return it.time = time, it;
      })(function(){
        var roll, v, i$;
        roll = +drawFrom({
          0: 20,
          1: 7,
          2: 1,
          3: 4
        });
        v = velocity(roller);
        for (i$ = 0; i$ < roll; ++i$) {
          v = [-v[1], v[0]];
        }
        return setVelocity(at(roller, time), v);
      });
    }
  }, ref$);
  grid = (function(){
    var i$, results$ = [];
    for (i$ = 0; i$ <= 10; ++i$) {
      i = i$;
      results$.push(create('wall', [i, i], [0, 10]));
    }
    return results$;
  }()).concat((function(){
    var i$, results$ = [];
    for (i$ = 0; i$ <= 10; ++i$) {
      i = i$;
      results$.push(create('wall', [0, 10], [i, i]));
    }
    return results$;
  }()));
  (prime = function(){
    var i$, ref$, len$, obj, results$ = [];
    for (i$ = 0, len$ = (ref$ = grid.concat(roller)).length; i$ < len$; ++i$) {
      obj = ref$[i$];
      results$.push(events.push({
        time: 0,
        type: 'add',
        obj: obj
      }));
    }
    return results$;
  })();
  if (require('repl').start != null) {
    ref$ = require('repl').start({
      input: process.stdin,
      output: process.stdout
    }).context;
    ref$.events = events;
    ref$.step = step;
    ref$.takeStep = takeStep;
    ref$.print = print;
    ref$.own = own;
    ref$.velocity = velocity;
    ref$.setVelocity = setVelocity;
    ref$.nextCollision = nextCollision;
    ref$.prime = prime;
    ref$.result = result;
  }
  if (typeof window != 'undefined' && window !== null) {
    window.result = result;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
  function flip$(f){
    return curry$(function (x, y) { return f(y, x); });
  }
}).call(this);
